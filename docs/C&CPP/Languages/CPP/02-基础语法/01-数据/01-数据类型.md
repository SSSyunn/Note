## 一、内置类型

### 1. 整数类型

| 类型             | 声明符                                                       | 最小尺寸 |
| ---------------- | ------------------------------------------------------------ | -------- |
| 短整型           | `short`、`short int`、`signed short`、`signed short int`     | 16 位    |
| 整型             | `int`、`signed int`                                          | 16 位    |
| 长整型           | `long`、`long int`、`signed long`、`signed long int`         | 32 位    |
| 扩展长整型       | `long long`、`long long int`、`signed long long`、`signed long long int` | 64 位    |
| 无符号短整型     | `unsigned short`、`unsigned short int`                       | 16 位    |
| 无符号整型       | `unsigned`、`unsigned int`                                   | 16 位    |
| 无符号长整型     | `unsigned long`、`unsigned long int`                         | 32 位    |
| 无符号扩展长整型 | `unsigned long long`、`unsigned long long int`               | 64 位    |

> 对于整型，标准只规定了它们的最小位数，但并未规定它们的最大位数。
>
> 但标准规定了它们与字节数的关系以及各整型之间的相对关系：
>
> `1`==`sizeof(char)`≤`sizeof(short)`≤`sizeof(int)`≤`sizeof(long)`≤`sizeof(long long)`
>
> 即`char`类型的位数一定和 1 字节的位数相等，通常为 8 位，但 1 字节并不一定为 8 位。



### 2. 布尔类型

| 类型     | 声明符 | 最小尺寸   |
| -------- | ------ | ---------- |
| 布尔类型 | `bool` | **未定义** |



### 3. 字符类型

| 类型          | 声明符                                | 最小尺寸 |
| ------------- | ------------------------------------- | -------- |
| 字符类型      | `char`(`signed char`/`unsigned char`) | 8 位     |
| 宽字符类型    | `wchar_t`                             | 16 位    |
| UTF16字符类型 | `char16_t`                            | 16 位    |
| UTF32字符类型 | `char32_t`                            | 32 位    |

> `char`类型可以用来表示最小的整数，但需要注意的是`char`类型具体是`signed char`还是`unsigned char`，标准并没有明确规定，即根据编译器的不同，`char`类型的具体实现也有可能不同。
>
> 故如果希望用`char`类型来表示整数，那么应该明确使用`signed char`或者`unsigned char`



### 4. 浮点类型

| 类型           | 声明符        | 最小尺寸      |
| -------------- | ------------- | ------------- |
| 单精度浮点数   | `float`       | 6 位有效数字  |
| 双精度浮点数   | `double`      | 10 位有效数字 |
| 扩展精度浮点数 | `long double` | 10 位有效数字 |



## 二、复合类型

### 1. 引用类型（左值引用）

```cpp
SomeType &Spec = SomeType_Variable;		// 创建一个SomeType的引用，初始化为SomeType的变量
```

> 一个引用即为其绑定对象的别名，在大多数时候可以像使用其绑定对象一样使用引用，相应的作用会作用在其绑定对象本体上。

其中，

- `SomeType`可拥有不同的 cv 限定

- 引用不允许修改其绑定对象，故引用类型必须被初始化为指代一个有效的对象或函数

  > 有效的对象或函数是指与引用的类型完全相同，除以下两种例外：
  >
  > - const 引用绑定到非 const 的对象
  > - 基类引用绑定到派生类对象

- 无法组成 “到 （可有 cv 限定的）void 的引用” 类型

- 引用类型不能在顶层有 cv 限定；如果在`typedef`名，`decltype`说明符或类型模板形参上添加了该限定符，它将会被忽略。如下所示：

  ```cpp
  SomeType &const Spec = SomeType_Variable;		// 错误：不存在该语法
  ```

- 引用不是对象，所以不存在引用的数组、指向引用的指针、引用的引用



### 2. 指针类型

```cpp
SomeType *Spec;			// 创建一个默认初始化的指向 SomeType 的指针
```

> 指针保存的值被解释为地址，和引用不同的是，指针是一个对象，我们可以直接操作其值，也可以通过它间接操作其指向的对象

其中，

- `SomeType`可拥有不同的 cv 限定

- 可对指针添加顶层 cv 限定，顶层 const 限定表示该指针无法指向其他对象

  ```cpp
  SomeType *const Spec;
  ```

- 不存在指向引用的指针和指向位域的指针

- 可定义指向 void 的指针，任何指针都可隐式转换为该类型，该类型需显式转换为其他指针类型

  ```cpp
  int n = 1;
  int* p1 = &n;
  void* pv = p1;						// 隐式转换
  int* p2 = static_cast<int*>(pv);	// 显式转换
  ```

- 指针类型的值是下列之一
  - 指向对象的指针（通过取地址符）
  - 指向函数的指针（通过取地址符，可忽略）
  - 对象末尾后指针
  - 该类型的空指针值（指针字面值、任何值为 0 的整数值、NULL 宏）
  - 无效指针值



### 3. 数组类型

```cpp
SomeType Spec[LENGTH];
```

> 数组创建一个相同类型的元素组合，它们在内存中的位置是连续的，通过`arrayName[Index]`的形式进行访问

其中，

- 数组可由任何（除 void 外的）基础类型、指针、成员指针、类、枚举，或从其他已知边界数组类型（这种情况下称数组是多维的）构成。换言之，只有除了未知边界数组以外的对象类型能成为数组类型的元素类型。拥有不完整元素类型的数组类型也是不完整类型。
- 不存在引用的数组或函数的数组。
- 数组长度`LENGTH`应该是求值为大于零的值的整数常量表达式
- 对数组类型（通过 typedef 或模板操作）应用 cv 限定符会将限定符应用到它的元素类型，但元素是有 cv 限定类型的任何数组类型都会被认为拥有相同的 cv 限定性。



### 4. 枚举类型

```cpp
enum Spec { ENUM_LIST };
```

> 枚举类型用于将一个分类的常量聚合起来，例如一周的每一天，一年的每一个月等等。优点在于可以用含有语义的常量代替一般整数，同时能够将一组常量聚合起来



## 三、类型的编码实现

### 1. 整数类型

如果整数只有无符号类型，那么整数的编码很简单就能统一，无非是将 10 进制或其他进制的整数转换为 2 进制。而由于有了带符号类型的存在，整数的编码才变得麻烦。

需要首要考虑的有两个问题，其一是符号问题，其二是 0 的表示。

目前最常使用的编码是**补码**，在此介绍该编码与另一种编码——**原码**的基本实现：

- **原码**：用最高位表示正负，其余位表示整数的绝对值。缺点在于 0 有两种表示方式，该编码保存的值需进行一些处理才能进行运算；
- **补码**：同样还是用最高位表示正负，但其余位不再表示整数的绝对值，其实现借助了反码，具体实现不在此处展开。其优点是 0 只有唯一的表示方法，且该数据连同符号位可直接参与运算而无需额外处理。



### 2. 布尔类型

布尔类型属于整型，原则上可以使用整数类型实现。但实际上，布尔类型只需要一个 bit 就能够实现，如果使用整数类型实现那么将会导致内存浪费。

布尔类型的最小尺寸并未定义，同时由于内存的最小访问单元为 Byte，故

- 最简单的实现方式是用一个 Byte 实现布尔类型，即 1 个布尔类型占 8 个 bit；
- 另一种实现方式是用一个 Byte 表示 8 个布尔类型变量，充分利用内存空间。



### 3. 字符(串)类型

字符类型属于整型，其保存的内容是字符对应的编码值。而由于字符集的不同，所以相同的字符可能对应的编码值也会不同。

程序中的字符(串)有两种来源，它们保存在程序中的字符编码如下：

1. 用户输入：用户输入的字符(串)所到的的编码取决于程序执行字符集，即用户输入的字符(串)在该字符集下的编码
2. 源文件字符(串)字面值（后续简称字面值）：字面值保存在程序中的编码由几个因素决定，分别是源文件编码、编译器按何种编码解释源文件、编译器所认为的执行环境的字符集、编译器所认为的执行环境的宽字符字符集。对于 GCC 编译器来说，后三者都可以在编译器中进行设定，后续分别用`input-char`、`exec-char`、`wexec-char`来表示编译器的这三个设定项，另外最后一个影响因素只对`wchar_t`类型的字符产生影响。编译器在编译时会将字面值从`input-char`转换为`exec-char`或`wexec-char`对应的编码。所以`input-char`选项很重要，它关系到编译器是否能正确识别源文件中的字面值，如果这一步不正确，那么后面的所有转换都是错误的。假设`input-char`设定值与源文件编码相同，那么：
   1. `char`类型（无任何前缀）的字符(串)保存为`exec-char`的设定值。特殊的，对于字符串而言，如果使用了`u8`前缀，则将保存为 UTF-8 编码
   2. `wchar_t`类型（使用前缀`L`）的字符(串)保存为`wexec-char`的设定值
   3. `char16_t`类型（使用前缀`u`）的字符(串)保存为 UTF16 编码
   4. `char32_t`类型（使用前缀`U`）的字符(串)保存为 UTF32 编码



### 4. 浮点类型

实数有两种表示方式，其一是定点表示法，其二是浮点表示法，而 C++ 使用的浮点类型很显然采用后者。

- 定点表示法：在二进制序列中确定某个位置，该位置前的二进制序列表示整数部分，小数点后的二进制序列表示小数部分。该表示方式的缺点在于整数部分和小数部分都有可能发生溢出，且无法表示过大的实数
- 浮点表示法：采用科学计数法的原理进行实现，即将一个二进制序列分为尾数和指数两个部分，前者决定了实数的精度，即有效位数；后者决定了实数的大小，即以 10 为底数的数量级



### 5. 引用类型

在语言定义中，引用类型是不必占用存储空间的，即引用类型无需编码。

但根据实际情况，引用类型为了实现其语义，通常编译器会为其分配存储空间，所储存值通常为所绑定对象的地址，与指针相似。

对某对象的引用进行操作相当于对指向该对象的指针进行解引用操作后再进行该操作。



### 6. 指针类型

指针类型保存整数，表示一个内存地址，该地址以字节为单位。

对于 32 位程序，表示一个内存地址需要 4 个字节，故 32 位程序中指针类型通常为 4 字节；

对于 64 位程序，表示一个内存地址需要 8 个字节，故 64 位程序种指针类型通常为 8 字节。



### 7. 数组类型

一个数组在内存中占据一段连续的空间，用来保存其元素。

一个数组类型有 2 个信息是必需的，一个是起始元素的地址，另一个是数组的长度。在抽象上，我们可以认为一个数组就由这两个信息以及其所占用的内存共同构成。

需要注意的是数组在很多地方会自动退化成指向其起始元素的指针，由于这个转换的存在，所以可能会认为数组就是指针。但不要忘了数组的组成要素还有数组长度。这在 C++ 的一些使用中可以体现出来区别，例如你可以对一个数组使用范围 for 语句，而不能对一个指向数组首元素的指针使用范围 for 语句。



## 四、字面值

### 1. 整数字面值

#### 语法

1. *十进制字面量 整数后缀~可选~*
2. *八进制字面量 整数后缀~可选~*
3. *十六进制字面量 整数后缀~可选~*

其中，

- 十进制字面量是非零十进制数字后随零或多个十进制数字
- 八进制字面量是数字 0 后随零或多个八进制数字
- 十六进制字面量是字符序列 0x 或字符序列 0X 后随一或多个十六进制数字
- 整数后缀为以下二者之一或两者皆有（若都有，则可以任意顺序出现）：
  - 无符号后缀（字符`u`或字符`U`）
  - 尺寸后缀（以下之一）
    - 长后缀（字符`l`或字符`L`）
    - 长长后缀（字符序列`ll`或字符序列`LL`）



#### 整数字面量的类型

整数字面量的类型，根据数字所用的进制和整数后缀共同决定。

根据不同的进制和整数后缀，每一个整数字面量都有一组待选类型，**整数的具体类型是该待选类型组中足以无损保存该字面量的最小类型**。不同字面量对应的待选类型如下表所示：

| 后缀                     | 十进制                                                       | 八进制、十六进制                                             |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| (无后缀)                 | `int`<br />`long int`<br />`long long int`                   | `int`<br />`unsigned int`<br />`long int`<br />`unsigned long int`<br />`long long int`<br />`unsigned long long int` |
| `u`或`U`                 | `unsigned int`<br />`unsigned long int`<br />`unsigned long long int` | `unsigned int`<br />`unsigned long int`<br />`unsigned long long int` |
| `l`或`L`                 | `long int`<br />`long long int`                              | `long int`<br />`unsigned long int`<br />`long long int`<br />`unsigned long long int` |
| 同时有`u`/`U`和`l`/`L`   | `unsigned long int`<br />`unsigned long long int`            | `unsigned long int`<br />`unsigned long long int`            |
| `ll`或`LL`               | `long long int`                                              | `long long int`<br />`unsigned long long int`                |
| 同时有`u`/`U`和`ll`/`LL` | `unsigned long long int`                                     | `unsigned long long int`                                     |



### 2. 布尔字面值

#### 语法

1. `true`
2. `false`



### 3. 字符字面值

#### 语法

1. *前缀~可选~ 'c字符'*

其中

- *c字符* 为下列之一：

  - 一个 *基本c字符*：*基本c字符* 为[基本源字符集](https://zh.cppreference.com/w/cpp/language/charset#.E5.9F.BA.E6.9C.AC.E6.BA.90.E5.AD.97.E7.AC.A6.E9.9B.86)去掉单引号（`'`），反斜杠（`\`）和换行符后的字符

  - 一个转义序列

    - 简单转义序列

      | 转义序列 |   描述   |           表示            |
      | :------: | :------: | :-----------------------: |
      |   `\'`   |  单引号  | ASCII 编码中为字节 `0x27` |
      |   `\"`   |  双引号  | ASCII 编码中为字节 `0x22` |
      |   `\?`   |   问号   | ASCII 编码中为字节 `0x3f` |
      |   `\\`   |  反斜杠  | ASCII 编码中为字节 `0x5c` |
      |   `\a`   |   响铃   | ASCII 编码中为字节 `0x07` |
      |   `\b`   |   退格   | ASCII 编码中为字节 `0x08` |
      |   `\f`   |   换页   | ASCII 编码中为字节 `0x0c` |
      |   `\n`   |   换行   | ASCII 编码中为字节 `0x0a` |
      |   `\r`   |   回车   | ASCII 编码中为字节 `0x0d` |
      |   `\t`   | 水平制表 | ASCII 编码中为字节 `0x09` |
      |   `\v`   | 垂直制表 | ASCII 编码中为字节 `0x0b` |

    - 数值转义序列

      | 转义序列 | 描述           | 表示                                   |
      | -------- | -------------- | -------------------------------------- |
      | `\nnn`   | 任意八进制值   | 代码单元`nnn`（1~3位八进制数位）       |
      | `\Xn...` | 任意十六进制值 | 代码单元`n...`（任意位数的十六进制数位 |

  - 一个通用字符名

    | 转义序列     | 描述                                  | 表示                                   |
    | ------------ | ------------------------------------- | -------------------------------------- |
    | `\Unnnn`     | 任意 Unicode 值：可能生成多个代码单元 | 代码点`U+nnnn`（4 位十六进制数位）     |
    | `\Unnnnnnnn` | 任意 Unicode 值：可能生成多个代码单元 | 代码点`U+nnnnnnnn`（8 位十六进制数位） |

    > 使用通用字符名时，也可以不使用转义序列的方式，直接在源代码中将字面值输入为对应的字符也可以，但需要保证字符可以正确转换为对应的 Unicode 编码，且当 Unicode 编码对应的字符大于 1 个字节时，需要添加适当的前缀修改字面值的类型

- 前缀可能是`L`、`u`、`U`中任意一种



#### 字符字面量的类型

- 不带任何前缀的字符字面值为`char`类型
- 带前缀`L`的字符字面值为`wchar_t`类型
- 带前缀`u`的字符字面值为`char16_t`类型
- 带前缀`U`的字符字面值为`char32_t`类型



### 4. 字符串字面值



### 5. 浮点类型字面值

#### 语法

1. *数字序列 十进制指数 后缀~可选~*
2. *数字序列 . 十进制指数~可选~ 后缀~可选~*
3. *数字序列~可选~ . 数字序列 十进制指数~可选~ 后缀~可选~*

其中，

- *数字序列* 为无小数点的整数
- *十进制指数* 为`e`/`E`加上指数部分，指数部分是一个带符号的整数，表示 $\times 10^n$
- 后缀为以下之一
  - `f`/`F`
  - `l`/`L`



#### 浮点数字面量的类型

- 不添加任何后缀，为`double`类型
- 添加`f`/`F`后缀，为`float`类型
- 添加`l`/`L`后缀，为`long double`类型



### 6. 指针字面值

#### 语法

```cpp
nullptr
```

- `nullptr`是`std::nullptr_t`类型的纯右值
- `nullptr`可以隐式转换为任何指针类型和任何成员指针类型



## 五、类型别名



## 六、推断类型

