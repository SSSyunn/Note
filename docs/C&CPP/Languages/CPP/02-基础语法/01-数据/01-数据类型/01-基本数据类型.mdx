## 一、void

- 该类型用于某些特殊场合下，不对应具体的值，如函数不返回值时的返回值类型

- `void*`类型，一个不指向具体类型的指针。仅能对该指针执行有限操作，包括：和别的指针比较、作为函数的输入或输出、或者赋值给另一个`void*`指针

  > **注意**：C++ 中 `void*`类型和 C 语言中不同。在 C 语言中，`void*`类型可以直接隐式转换为其他任何指针类型，而在 C++ 中，`void*`类型到其他指针类型的转换只能显式进行



## 二、std::nullptr_t

- 专用于指针字面量`nullptr`的类型，该类型可以隐式转换为任意指针类型，但无法隐式转换为任意非指针类型
- 可以认为`std::nullptr_t`类型是对`void*`类型做了封装。这是一个纯右值类型，其值只会是空指针字面值`nullptr`
- 在要求使用该类型名的地方应该尽量避免直接使用，而使用`decltype(nullptr)`的形式来代替

> **为什么要有`std::nullptr_t`类型**：
>
> 创建指针时有三个方法可以将该指针初始化为空指针：赋值为 0、赋值为 `NULL`（宏常量）、赋值为 `nullptr`。这三个值用来初始化指针时得到的结果完全相同。
>
> 在 C 语言中，`NULL`通常定义为`(void*)0`，但在 C++ 中，`void*`类型并不能隐式转换为其他指针类型，所以在 C++ 中，`NULL`被定义为 0，而这将会带来歧义。在一组重载函数中，如果两个函数一个需要整数参数，一个需要指针参数，当我们传入 `NULL` 时，将毫无疑问调用需要整数参数的函数，但根据语义来看其想要调用的函数应该是接受指针参数的函数。



## 三、算术类型

### 1. bool

**用法**：`bool`类型变量只有两个值，`true`或`false`

**实现**：`bool`类型的最小实现位数并未定义，或许使用 1 Byte 保存单个`bool`变量，也可能使用 1 Byte 保存 8 个`bool`变量

**字面值**：`true`、`false`



### 2. char系

**简介**：包括`char`、`signed char`、`unsigned char`、`wchar_t`、`char16_t`、`char32_t`类型。

**实现**

- `char`、`signed char`、`unsigned char`类型的位数实现为 1 Byte；而`char16_t`和`char32_t`类型的位数分别实现为 16 bit 和 32 bit；`wchar_t`类型的位数根据平台的不同会有区别，可能为 16 bit 或 32 bit
- 字符类型本质保存的是整数，当我们用字符字面量作为值时，其保存的是该字面量在某字符集中的编码，该编码和整数值可以一一对应的转换

- 根据字符类型的特性，我们可以用`char`类型来保存比`short`还小的整数，但`char`类型并未规定默认实现为`signed char`或`unsigned char`类型中的某一个，所以我们如果要用字符类型来保存小整数，应该使用`signed char`或`unsigned char`类型而非`char`类型

**字面值**

- 字符字面值

  - 单引号括起来的字符：`'a'`

  - 转义序列：`'\n'`、`'\0'`、`'\x4d'`

    > 转义序列包括两种，一种是语义化的符号，例如：`\n`、`\\`、`\b`等；
    >
    > 另一种是泛化的转义序列，其形式是`\`后跟 1-3 个八进制数字或`\x`后跟 1 个或多个十六进制数字

- 字符串字面值

  - 双引号括起来的字符序列：`"abcd\n\123\x4d"`。字符串中的字符可以是任何字符字面值

    > 字符串字面值实际上是一个字符数组，该数组的长度为实际字符个数 + 1，因为在字符串末尾还有有一个`'\0'`字符会被隐式添加进字符串中

- 前缀

  - `u`：表示字符或字符串中的字符为`char16_t`类型
  - `U`：表示字符或字符串中的字符为`char32_t`类型
  - `L`：表示字符或字符串中的字符为`wchar_t`类型
  - `u8`（仅字符串）：字符串中的字符为`char`类型，但会转换为`utf-8`编码