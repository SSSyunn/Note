## 一、安装

```bash
python -m pip install pytest
```



## 二、使用

### 1. 测试函数

如果不使用`pytest`，对一个函数进行测试通常需要写一段直接执行的测试代码，然后执行它，再手动输入测试参数，然后肉眼观察输出结果是否正确。在这种前提下，我们每次修改了函数的代码时，都需要重复以上操作来测试，且有些函数需要多种且大量的参数进行测试，手动测试在这种情况下就显得比较繁琐、低效、覆盖率低。

如果使用`pytest`，那么我们可以针对某个或某几个待测试函数定义一个测试函数，这些测试函数需要保持一定的命名规则。当我们运行`pytest`时，它会自动收集需要测试的项目（我们定义的测试函数），然后依次执行这些测试函数，最后返回统计之后的测试结果。

注：实际上，`pytest`的功能仅仅是收集测试函数并执行它们，并没有其他功能。对于我们要测试的函数来说，如果你在测试函数中只调用了这个待测试函数一次，那么`pytest`也只执行其一次，它并不会自动用大量的随机的参数去调用这个待测试函数

**总结如下**：

- `pytest`的作用是自动收集测试函数并执行它们并返回统计后的测试结果，在此层面上，`pytest`仅避免了人工反复调用函数并手工输入参数的复杂工作，但还并没解决测试参数的普遍性

- `pytest`会自动收集测试文件（以`test_*.py`或`*_test.py`命名的文件）中的测试函数（以`test_*()`命名的函数）并执行它们

- 在测试函数中，通过`assert`语句来为`pytest`提供测试结果，当`assert`语句为`True`时，程序测试结果为成功，否则结果为失败，例如：

  ```python
  def test_add():
      sum = add(1, 2)
      assert sum == 3
  ```

  在这个测试函数（`test_add()`）中，我们测试了`add()`函数，提供了一组参数（1 和 2），程序会执行这个函数调用，如果没有后面的`assert`语句，那么这个测试就没有太大的意义，最多只能判断以这组参数调用`add`函数是否会导致程序错误，但并不能判断执行这个函数是否能得到正确的结果，假设当`add`函数实际执行的是乘法运算时，执行这个函数并不会报错，如果没有`assert`语句，我们并不能发现它实际上的实现并不是加法运算。

  `assert`语句用来确认函数的运行结果是否和我们预想的相同。在有了`assert`语句后，`pytest`目前才终于可以自动化测试单组固定参数的调用是否正确了

- 为了测试多组固定数据，一个直觉的方法是在函数里创建一个需要测试的所有参数组合的列表，然后循环访问这个列表中的每一组参数，在循环中我们用这一组参数调用待测试函数然后对其结果进行判定。但实际上这个方法行不通，因为无论如何这个测试函数目前来说只会执行一次，只要在这一次执行中某个`assert`语句报错，那么这一次测试函数的结果就是失败，无论已经有多少次迭代是成功的。

  `pytest`提供的方法是参数化测试，具体方法是在测试函数前添加一行：

  ```python
  @pytest.mark.parametrize('para_name', value_list)		# 添加的内容
  def test_func(para_name):
      assert func(para_name) == want_value
  ```

  这一行接受两个参数，第一个是一个字符串，第二个是任何可以在`for`循环中充当范围的表达式（包括列表、`range`函数等）。它将定义一个变量，这个变量的名字就是字符串的内容，这个变量将在`value_list`中依次取值，每次取值都将执行一次测试函数并将结果加入统计。

  通过这种方法，我们目前已经可以使用`pytest`实现自动化测试多组固定参数的函数调用

- 基于以上基础，我们可以轻松得到测试超大量的固定数据的方法。为了测试更大量的固定数据，可以将这些数据写入到文件中，然后通过`Path`类读取文件中的内容得到所有测试数据的一个列表，然后再使用参数化的方法进行测试。待测试固定数据应该具有代表性、普遍性，以达到测试数据的高覆盖性

- 最后是测试随机数据的方法。我们可以首先定义需要测试的随机数据的数量，然后创建一个列表，该列表的元素个数应该和需要的随机数据数量相同且元素不重复，我们将这个列表作为随机数种子，通常我们可以直接使用`range`函数来创建这样的种子列表。然后使用参数化的方法用每一个种子调用测试函数，在测试函数中，我们首先需要根据这个随机数种子生成随机数，然后用这个随机数调用待测试函数。随机数据几乎可以保证测试数据的普遍性，但并不一定具有代表性，优点是不需要手动创建测试用数据



### 2. 测试类

- 测试类的方法实际上和测试函数的方法基本相同，不过类测试并不是单纯的函数调用测试，在测试函数中我们需要创建类对象，然后使用它的一系列方法，然后把我们需要测试的内容用`assert`语句表达出来即可

- 由于 Python 的垃圾回收机制，我们在一个测试中创建的类对象所占据的内存在当前单元测试结束时并不会自动回收，所以如果每一次的执行都会创建大量相同或相似的类对象时，我们就可以使用**夹具**，夹具的创建方法如下：

  ```python
  @pytest.fixture
  def get_class_instance():
      var = class_name(init_para_list)
      return var
  ```

  这样我们就创建好了一个夹具，即`get_class_instance`，夹具用来设置测试所需的资源并确保这些资源在测试结束后被正确清理。

  在后续的测试函数中，我们如果想要使用这个夹具，就需要将其作为参数之一传递：

  ```python
  def test_func(get_class_instance):
      assert get_class_install.func() == want_value
  ```

- 如果需要测试多种初始值的类对象，就可以使用带参数的夹具，和参数化测试函数类似，参数化夹具可以令使用了夹具的测试函数测试多次，每一次都用不同的参数初始化夹具，具体方法如下：

  ```python
  @pytest.fixture(params=[para1, para2, para3])
  def instance(request):
      return class_name(request.param)
  ```

  在`pytest`中，`request`是一个特殊的内置对象，它提供了访问当前测试的上下文信息，在`fixture`中定义的参数列表中的参数会在依次将值赋予每一次测试中的`request.param`属性，我们可以通过这个表达式来获取当前一次测试中的参数